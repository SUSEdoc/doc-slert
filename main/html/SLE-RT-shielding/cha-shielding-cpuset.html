<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><title>SLE RT 15 SP6 | Shielding Linux Resources | Full-featured cpuset manipulation commands</title><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes"/><link rel="stylesheet" type="text/css" href="static/css/style.css"/>
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"/><link rel="schema.DCTERMS" href="http://purl.org/dc/terms/"/>
<meta name="title" content="Full-featured cpuset manipulation commands | SLE RT 15 SP6"/>
<meta name="description" content="While basic shielding as described above is useful and…"/>
<meta name="product-name" content="SUSE Linux Enterprise Real Time"/>
<meta name="product-number" content="15 SP6"/>
<meta name="book-title" content="Shielding Linux Resources"/>
<meta name="chapter-title" content="Chapter 4. Full-featured cpuset manipulation commands"/>
<meta name="tracker-url" content="https://bugzilla.suse.com/enter_bug.cgi"/>
<meta name="tracker-type" content="bsc"/>
<meta name="tracker-bsc-assignee" content="thomas.schraitle@suse.com"/>
<meta name="tracker-bsc-component" content="Documentation"/>
<meta name="tracker-bsc-product" content="SUSE Linux Enterprise Real Time 15 SP6"/>
<meta name="publisher" content="SUSE"/><meta property="og:title" content="Full-featured cpuset manipulation commands | SLE RT 15…"/>
<meta property="og:description" content="While basic shielding as described above is useful and a common use model for cset, there comes a time when more functionali…"/>
<meta property="og:type" content="article"/>
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Full-featured cpuset manipulation commands | SLE RT 15…"/>
<meta name="twitter:description" content="While basic shielding as described above is useful and a common use model for cset, there comes a time when more functionali…"/>
<link rel="prev" href="cha-shielding-with-systemd.html" title="Chapter 3. Shielding with systemd"/><link rel="next" href="cha-shielding-shortcuts.html" title="Chapter 5. Using shortcuts"/><script type="text/javascript">

if ( window.location.protocol.toLowerCase() != 'file:' ) {
  document.write('<link rel="stylesheet" type="text/css" href="https://documentation.suse.com/docserv/res/fonts/poppins/poppins.css"></link>');
};

</script><noscript><link rel="stylesheet" type="text/css" href="https://documentation.suse.com/docserv/res/fonts/poppins/poppins.css"/></noscript><script src="static/js/jquery-1.12.4.min.js" type="text/javascript"> </script><script src="static/js/script.js" type="text/javascript"> </script><script src="static/js/highlight.min.js" type="text/javascript"> </script><script>

$(document).ready(function() {
  $('.verbatim-wrap.highlight').each(function(i, block) {
    hljs.highlightBlock(block);
  });
});
hljs.configure({
  useBR: false
});

</script><meta name="edit-url" content="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml"/></head><body class="draft wide offline js-off" onload="$('#betawarn-button-wrap').toggle();if (document.cookie.length > 0) {if (document.cookie.indexOf('betawarn=closed') != -1){$('#betawarn').toggle()}};"><div id="betawarn" style="position:fixed;bottom:0;z-index:9025;background-color:#FDE8E8;padding:1em;margin-left:10%;margin-right:10%;display:block;border-top:.75em solid #E11;width:80%"><p style="color:#333;margin:1em 0;padding:0;">This is a draft document that was built and uploaded automatically. It may document beta software and be incomplete or even incorrect. <strong>Use this document at your own risk.</strong></p> <div id="betawarn-button-wrap" style="display:none;margin:0;padding:0;"><a href="#" onclick="$('#betawarn').toggle();var d=new Date();d.setTime(d.getTime()+(0.5*24*60*60*1000));document.cookie='betawarn=closed; expires='+d.toUTCString()+'; path=/'; return false;" style="color:#333;text-decoration:underline;float:left;margin-top:.5em;padding:1em;display:block;background-color:#FABEBE;">I understand this is a draft</a></div></div><div class="bypass-block"><a href="#_content">Jump to content</a><a href="#_bottom-pagination">Jump to page navigation: previous page [access key p]/next page [access key n]</a></div><header id="_mainnav"><div class="growth-inhibitor"><img src="static/images/logo.svg" alt="Logo" class="logo"/></div></header><div class="crumbs"><div class="growth-inhibitor"><a class="crumb" href="index.html">Shielding Linux Resources</a><span> / </span><a class="crumb" href="cha-shielding-cpuset.html">Full-featured cpuset manipulation commands</a></div></div><main id="_content"><nav id="_side-toc-overall" class="side-toc"><div class="side-title">Shielding Linux Resources</div><ol><li><a href="cha-shielding-intro.html" class=" "><span class="title-number">1 </span><span class="title-name">Introduction</span></a></li><li><a href="cha-shielding-model.html" class=" "><span class="title-number">2 </span><span class="title-name">The basic shielding model</span></a></li><li><a href="cha-shielding-with-systemd.html" class=" "><span class="title-number">3 </span><span class="title-name">Shielding with systemd</span></a></li><li><a href="cha-shielding-cpuset.html" class=" you-are-here"><span class="title-number">4 </span><span class="title-name">Full-featured cpuset manipulation commands</span></a></li><li><a href="cha-shielding-shortcuts.html" class=" "><span class="title-number">5 </span><span class="title-name">Using shortcuts</span></a></li><li><a href="cha-shieldingt-help.html" class=" "><span class="title-number">6 </span><span class="title-name">What to do if there are problems</span></a></li><li><a href="bk01apa.html" class=" "><span class="title-number">A </span><span class="title-name">GNU Licenses</span></a></li> </ol> </nav><button id="_open-side-toc-overall" title="Contents"> </button><article class="documentation"><button id="_unfold-side-toc-page">On this page</button><section class="chapter" id="cha-shielding-cpuset" data-id-title="Full-featured cpuset manipulation commands"><div class="titlepage"><div><div class="version-info">Applies to  <span class="productname">SUSE Linux Enterprise Real Time</span> <span class="productnumber">15 SP6</span></div><div><div class="title-container"><h1 class="title"><span class="title-number-name"><span class="title-number">4 </span><span class="title-name">Full-featured cpuset manipulation commands</span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#">#</a></h1><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
  While basic shielding as described above is useful and a common use model
  for <code class="command">cset</code>, there comes a time when more functionality
  will be desired to implement your strategy. To implement this,
  <code class="command">cset</code> provides two subcommands: <code class="command">set</code>,
  which allows you to manipulate cpusets; and <code class="command">proc</code>, which
  allows you to manipulate processes within those cpusets.
 </p><section class="sect1" id="sec-shielding-cpuset-set" data-id-title="The set subcommand"><div class="titlepage"><div><div><div class="title-container"><h2 class="title"><span class="title-number-name"><span class="title-number">4.1 </span><span class="title-name">The set subcommand</span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#sec-shielding-cpuset-set">#</a></h2><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
   To do anything with cpusets, you must be able to create, adjust,
   rename, move, and destroy them. The <code class="command">set</code> subcommand
   allows the management of cpusets in such a manner.
  </p><section class="sect2" id="sec-shielding-cpuset-set-create-destroy" data-id-title="Creating and destroying cpusets with set"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">4.1.1 </span><span class="title-name">Creating and destroying cpusets with <code class="command">set</code></span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#sec-shielding-cpuset-set-create-destroy">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    The basic syntax of <code class="command">set</code> for cpuset creation is:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -c 1-3 -s my_cpuset1
cset: --&gt; created cpuset "my_cpuset1"</pre></div><p>
    This creates a cpuset named <code class="literal">my_cpuset1</code> with a CPUSPEC
    of CPU1, CPU2 and CPU3. The CPUSPEC is the same concept as described in
    the <a class="xref" href="cha-shielding-model.html#sec-shielding-model-ex-setup-teardown" title="2.2. Setup and teardown of the shield">Section 2.2, “Setup and teardown of the shield”</a>. The
    <code class="command">set</code> subcommand also takes a <code class="option">-m</code>/<code class="option">--mem</code>
    option that lets you specify the memory nodes the <code class="command">set</code>
    will use and flags to make the CPUs and MEMs exclusive to the
    cpuset. If you are on a non-NUMA machine, leave the
    <code class="option">-m</code> option out and the default memory node
    <code class="literal">0</code> will be used.
   </p><p>
    Like with <code class="command">shield</code>, you can adjust the CPUs and
    MEMs with subsequent calls to set. If, for example, you want to adjust
    the <code class="literal">my_cpuset1</code> cpuset to only use CPUs 1 and 3 (and
    omit CPU2), then issue the following command.
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -c 1,3 -s my_cpuset1
cset: --&gt; modified cpuset "my_cpuset</pre></div><p>
    <code class="command">cset</code> will then adjust the CPUs that are assigned to
    the <code class="literal">my_cpuset1</code> set to only use CPU1 and CPU3.
   </p><p>
    To rename a cpuset, use the <code class="option">-n/--newname</code> option. For
    example:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -s my_cpuset1 -n super_set
cset: --&gt; renaming "/cpusets/my_cpuset1" to "super_set"</pre></div><p>
    Renames the cpuset called <code class="literal">my_cpuset1</code> to
    <code class="literal">super_set</code>.
   </p><p>
    To destroy a cpuset, use the <code class="option">-d/--destroy</code> option as
    follows.
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -d super_set
cset: --&gt; processing cpuset "super_set", moving 0 tasks to parent "/"...
cset: --&gt; deleting cpuset "/super_set"
cset: done</pre></div><p>
    This command destroys the newly created cpuset called
    <code class="literal">super_set</code>. When a cpuset is destroyed, all the tasks
    running in it are moved to the parent cpuset. The root cpuset, which
    always exists and always contains all CPUs, cannot be destroyed. You may
    also give the <code class="option">--destroy</code> option a list of cpusets to
    destroy.
   </p><div id="id-1.3.6.3.3.14" data-id-title="Information about the mounted cpuset file system" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.svg"/><div class="admon-title">Note: Information about the mounted cpuset file system</div><p>
     The <code class="command">cset</code> subcommand creates the cpusets based on a
     mounted cpuset file system. You do not need to know where that file
     system is mounted, although it is easy to figure out (by default it is
     on <code class="filename">/cpusets</code>). When you give the
     <code class="command">set</code> subcommand a name for a new cpuset, it is
     created wherever the cpuset file system is mounted.
    </p></div><p>
    To create a cpuset hierarchy, then you must give a path to
    the <code class="command">cset set</code> subcommand. This path will always begin
    with the root cpuset, for which the path is <code class="filename">/</code>. For
    example:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -c 1,3 -s top_set
cset: --&gt; created cpuset "top_set"


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set -c 3 -s /top_set/sub_set
cset: --&gt; created cpuset "/top_set/sub_set"</pre></div><p>
    These commands created two cpusets: <code class="literal">top_set</code> and
    <code class="literal">sub_set</code>. The <code class="literal">top_set</code> uses CPU1 and
    CPU3. It has a subset of <code class="literal">sub_set</code> which only uses
    CPU3. Once you have created a subset with a path, then if the name is
    unique, you do not need to specify the path to affect it. If
    the name is not unique, then <code class="command">cset</code> will complain and
    ask you to use the path. For example:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -c 1,3 -s sub_set
cset: --&gt; modified cpuset "sub_set</pre></div><p>
    This command adds CPU1 to the <code class="literal">sub_set</code> cpuset for its
    use. Note that using the path in this case is optional.
   </p><p>
    If you attempt to destroy a cpuset which has sub-cpusets,
    <code class="command">cset</code> will complain and not do it unless you use the
    <code class="option">-r/--recurse</code> and the <code class="option">--force</code> options.
    If you do use <code class="option">--force</code>, then all the tasks running in
    all subsets of the deletion target cpuset will be moved to the
    target’s parent cpuset and all cpusets.
   </p><p>
    Moving a cpuset from under a certain cpuset to a different location is
    not implemented.
   </p></section><section class="sect2" id="sec-shielding-cpuset-set-list" data-id-title="Listing cpusets with set"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">4.1.2 </span><span class="title-name">Listing cpusets with set</span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#sec-shielding-cpuset-set-list">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    To list cpusets, use the <code class="command">set</code> subcommand with the
    <code class="option">-l/--list</code> option. For example:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -l
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
root         0-3 y        0 y       320   1    /
one          3 n          0 n       0     1    /one</pre></div><p>
    This shows that there is currently one cpuset present called
    <code class="literal">one</code>. (Of course there is also the
    <code class="literal">root</code> set, which is always present.) The output shows
    that the one cpuset has no tasks running in it. The
    <code class="literal">root</code> cpuset has 320 tasks running. The
    <code class="option">-X</code> for CPUs and MEMs fields denotes whether the CPUs
    and MEMs in the cpusets are marked exclusive to those cpusets. Note that
    the <code class="literal">one</code> cpuset has subsets as indicated by a
    <code class="literal">1</code> in the <code class="literal">Subs</code> field. You can
    specify a cpuset to list with the <code class="command">set</code> subcommand as
    follows:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -l -s one
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
one          3 n          0 n       0     1   /one
two          3 n          0 n       0     1   /one/two</pre></div><p>
    This output shows that there is a cpuset called <code class="literal">two</code>
    in cpuset <code class="literal">one</code> and it also has subset. You can also
    ask for a recursive listing as follows:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -l -r
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
root         0-3 y        0 y       320   1    /
one          3 n          0 n       0     1    /one
two          3 n          0 n       0     1    /one/two
three        3 n          0 n       0     0    /one/two/three</pre></div><p>
    This command lists all cpusets existing on the system since it asks for
    a recursive listing beginning at the <code class="literal">root</code> cpuset.
    Incidentally, should you need to specify the <code class="literal">root</code>
    cpuset you can use either <code class="filename">root</code> or
    <code class="filename">/</code> to specify it explicitly—just remember that the
    <code class="literal">root</code> cpuset cannot be deleted or modified.
   </p></section></section><section class="sect1" id="sec-shielding-cpuset-proc" data-id-title="The proc subcommand"><div class="titlepage"><div><div><div class="title-container"><h2 class="title"><span class="title-number-name"><span class="title-number">4.2 </span><span class="title-name">The <code class="command">proc</code> subcommand</span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#sec-shielding-cpuset-proc">#</a></h2><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
   Now that you know how to create, rename and destroy cpusets with the
   <code class="command">set</code> subcommand, the next step is to manage threads and
   processes in those cpusets. The subcommand to do this is called
   <code class="command">proc</code> and it allows you to execute processes into a
   cpuset, move existing tasks around existing cpusets, and list tasks
   running in specified cpusets. For the following examples, let us assume a
   cpuset setup of two sets as follows:
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -l
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
root         0-3 y        0 y       309   2    /
two          2 n          0 n       3     0    /two
three        3 n          0 n       10    0    /three</pre></div><section class="sect2" id="sec-shielding-cpuset-proc-list" data-id-title="Listing tasks with proc"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">4.2.1 </span><span class="title-name">Listing tasks with <code class="command">proc</code></span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#sec-shielding-cpuset-proc-list">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    Operation of the <code class="command">proc</code> subcommand follows the same
    model as the <code class="command">set</code> subcommand. For example, to list
    tasks in a cpuset, you need to use the <code class="option">-l/--list</code> option
    and specify the cpuset by name or, if the name exists multiple times in
    the cpuset hierarchy, by path. For example:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -l -s two
cset: "two" cpuset of CPUSPEC(2) with 3 tasks running
USER     PID   PPID  SPPr TASK NAME
-------- ----- ----- ---- ---------
root     16141 4300  Soth bash
root     16171 16141 Soth bash
root     16703 16171 Roth python ./cset proc -l two</pre></div><p>
    This output shows us that the cpuset called two has CPU2 only attached
    to it and is running three tasks: two shells and the
    <code class="command">python</code> command to list it. Note that cpusets are
    inherited so that if a process is contained in a cpuset, then any
    children it spawns also run within that set. In this case, the
    <code class="command">python</code> command to list set <code class="literal">two</code> was
    run from a shell already running in set <code class="literal">two</code>. This can
    be seen by the PPID (parent process ID) of the <code class="command">python</code>
    command matching the PID of the shell.
   </p><p>
    Additionally, the <code class="literal">SPPr</code> field needs explanation. SPPr
    stands for <code class="literal">State, Policy and Priority</code>. You can see
    that the initial two tasks are stopped and running in timeshare
    priority, marked as <code class="literal">oth</code> (for
    <code class="literal">other</code>). The last task is marked as running,
    <code class="literal">R</code> and at timeshare priority,
    <code class="literal">oth</code>. If any of these tasks would have been at real
    time priority, the policy would be shown as <code class="literal">f</code>
    for FIFO or <code class="literal">r</code> for round robin. The priority would
    be a number from 1 to 99. See below for an example.
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -l -s root | head -7
cset: "root" cpuset of CPUSPEC(0-3) with 309 tasks running
USER     PID   PPID  SPPr TASK NAME
-------- ----- ----- ---- ---------
root        1     0 Soth init [5]
root        2     0 Soth [kthreadd]
root        3     2 Sf99 [migration/0]
root        4     2 Sf99 [posix_cpu_timer]</pre></div><p>
    This output shows the first few tasks in the <code class="literal">root</code>
    cpuset. Note that both <code class="literal"> init</code> and
    <code class="literal">[kthread]</code> are running at timeshare; however, the
    <code class="literal">[migration/0]</code> and
    <code class="literal">[posix_cpu_timer]</code> kernel threads are running at
    real-time policy of FIFO and priority of <code class="literal">99</code>.
    Incidentally, this output is from a system running the real-time Linux
    kernel which runs some kernel threads at real-time priorities. And
    finally, note that you can use <code class="command">cset</code> as any other
    Linux tool and include it in pipelines as in the example above.
   </p><p>
    Taking a peek into the third cpuset called <code class="literal">three</code>, you
    can see output such as:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -l -s three
cset: "three" cpuset of CPUSPEC(3) with 10 tasks running
USER     PID   PPID  SPPr TASK NAME
-------- ----- ----- ---- ---------
tux      16165     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      16169     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      16170     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      16237     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      16491     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      16492     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      16493     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      17243     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      17244     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      17265     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...</pre></div><p>
    This output shows that a lot of <code class="literal">beagled</code> tasks are
    running in this cpuset and it also shows an ellipsis
    (<code class="literal">…</code>) at the end of their listings. If you see this
    ellipsis, that means that the command was too long to fit onto an 80
    character screen. To see the entire command line, use the
    <code class="option">-v/--verbose</code> flag:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -l -s three -v | head -4
cset: "three" cpuset of CPUSPEC(3) with 10 tasks running
USER     PID   PPID  SPPr TASK NAME
-------- ----- ----- ---- ---------
tux      16165     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg --autostarted --indexing-delay 300</pre></div></section><section class="sect2" id="sec-shielding-cpuset-proc-exec" data-id-title="Execing tasks with proc"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">4.2.2 </span><span class="title-name">Execing tasks with <code class="literal">proc</code></span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#sec-shielding-cpuset-proc-exec">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    To execute a task into a cpuset, the <code class="command">proc</code> subcommand
    needs to be employed with the <code class="option">-e/--exec</code> option. Let us
    execute a shell into the cpuset named <code class="literal">two</code> in our set.
    First, check to see what is running that set:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -l -s two
cset: "two" cpuset of CPUSPEC(2) with 0 tasks running

<code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -s two -e bash
cset: --&gt; last message, executed args into cpuset "/two", new pid is: 20955

<code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -l -s two
cset: "two" cpuset of CPUSPEC(2) with 2 tasks running
USER     PID   PPID  SPPr TASK NAME
-------- ----- ----- ---- ---------
root     20955 19253 Soth bash
root     20981 20955 Roth python ./cset proc -l two</pre></div><p>
    You can see that initially, <code class="literal">two</code> had nothing running
    in it. After the completion of the second command, list
    <code class="literal">two</code> again and see that there are two tasks running:
    the shell which you executed and the <code class="command">python cset</code> command
    that is listing the cpuset. The reason for the second task is that the
    cpuset property of a running task is inherited by all its children.
    Because you executed the listing command from the new shell which was bound
    to cpuset two, the resulting process for the listing is also bound to
    cpuset <code class="literal">two</code>. Let us test that by running a new
    shell with no prefixed <code class="command">cset</code> command.
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">bash</code>


<code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -l -s two
cset: "two" cpuset of CPUSPEC(2) with 3 tasks running
USER     PID   PPID  SPPr TASK NAME
-------- ----- ----- ---- ---------
root     20955 19253 Soth bash
root     21118 20955 Soth bash
root     21147 21118 Roth python ./cset proc -l two</pre></div><p>
    Here again, you can see that the second shell, PID <code class="literal">21118</code>,
    has a parent PID of <code class="literal">20955</code> which is the first shell.
    Both shells, and the listing command, are running in the two cpuset.
   </p><div id="id-1.3.6.4.5.7" data-id-title="Separating the Tool Options From the cset Command" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.svg"/><div class="admon-title">Note: Separating the Tool Options From the cset Command</div><p>
     <code class="command">cset</code> follows the tradition of separating the tool
     options from the command to be executed options with a double hyphen
     (<code class="literal">--</code>). This is not shown in this simple example, but
     if the command you want to execute also takes options, separate them with
     the double hyphen as follows:
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -s myset -e mycommand -- -v</pre></div><p>
     The <code class="option">-v</code> will be passed to
     <em class="replaceable">mycommand</em>, and not to <code class="option">cset</code>.
    </p></div><div id="id-1.3.6.4.5.8" data-id-title="Executing a shell into a cpuset" class="admonition tip normal"><img class="symbol" alt="Tip" title="Tip" src="static/images/icon-tip.svg"/><div class="admon-title">Tip: Executing a shell into a cpuset</div><p>
     Executing a shell into a cpuset is a useful way to experiment with
     running tasks in that cpuset since all children of the shell will also
     run in the same cpuset.
    </p></div><p>
    If you misspell the command to be
    executed, the result may be puzzling. For example:
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -s two -e blah-blah
cset: --&gt; last message, executed args into cpuset "/two", new pid is: 21655
cset: **&gt; [Errno 2] No such file or directory</pre></div><p>
    The result is no new process even though a new PID is output. The reason
    for the message is of course that the <code class="command">cset</code> process
    forked in preparation of the execution, but the command
    <code class="command">blah-blah</code> was not found to execute it.
   </p></section><section class="sect2" id="sec-shielding-cpuset-proc-move" data-id-title="Moving tasks with proc"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">4.2.3 </span><span class="title-name">Moving tasks with <code class="command">proc</code></span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#sec-shielding-cpuset-proc-move">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    Although the ability to execute a task into a cpuset is fundamental, you
    will most likely be moving tasks between cpusets more often. Moving
    tasks is accomplished with the <code class="option">-m/--move</code> and
    <code class="option">-p/--pid</code> options to the <code class="command">proc</code>
    subcommand of <code class="command">cset</code>. The <code class="option">move</code> option
    tells the <code class="command">proc</code> subcommand that a task move is
    requested. The <code class="option">-p/--pid</code> option takes an argument called
    a PIDSPEC (PID Specification). The PIDSPEC defines which tasks get
    operated on.
   </p><p>
    The PIDSPEC can be a single process ID, a list of process IDs separated
    by commas, and a list of process ID ranges also separated by commas. For
    example:
   </p><div class="variablelist"><dl class="variablelist"><dt id="id-1.3.6.4.6.4.1"><span class="term"><code class="option">--pid</code> 1234</span></dt><dd><p>
       This PIDSPEC argument specifies that PID <code class="literal">1234</code> will be
       moved.
      </p></dd><dt id="id-1.3.6.4.6.4.2"><span class="term"><code class="option">--pid</code> 1234,42,1934,15000,15001,15002</span></dt><dd><p>
       This PIDSPEC argument specifies that only listed tasks will be
       moved.
      </p></dd><dt id="id-1.3.6.4.6.4.3"><span class="term"><code class="option">-p</code> 5000,5100,6010-7000,9232</span></dt><dd><p>
       This PIDSPEC argument specifies that tasks <code class="literal">5000</code>,
       <code class="literal">5100</code> and <code class="literal">9232</code> will be moved along
       with any existing task with PID in the range <code class="literal">6010</code>
       through <code class="literal">7000</code> inclusive.
      </p></dd></dl></div><div id="id-1.3.6.4.6.5" data-id-title="Information about the range in a PIDSPEC" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.svg"/><div class="admon-title">Note: Information about the range in a PIDSPEC</div><p>
     A range in a PIDSPEC does not need to have running tasks for every
     number in that range. In fact, it is not even an error if there are no
     tasks running in that range; none will be moved in that case. The range
     simply specifies to act on any tasks that have a PID or TID that is
     within that range.
    </p></div><p>
    The following example moves the current shell into the cpuset
    named <code class="literal">two</code> with a range PIDSPEC and back out to the
    <code class="literal">root</code> cpuset with the Bash variable for the current
    PID.
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -l -s two
cset: "two" cpuset of CPUSPEC(2) with 0 tasks running


<code class="prompt user">tux &gt; </code><code class="command">echo</code> $$
19253


<code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -m -p 19250-19260 -t two
cset: moving following pidspec: 19253
cset: moving 1 userspace tasks to /two
cset: done


<code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -l -s two
cset: "two" cpuset of CPUSPEC(2) with 2 tasks running
USER     PID   PPID  SPPr TASK NAME
-------- ----- ----- ---- ---------
root     19253 16447 Roth bash
root     29456 19253 Roth python ./cset proc -l -s two


<code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -m -p $$ -t root
cset: moving following pidspec: 19253
cset: moving 1 userspace tasks to /
cset: done


<code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -l -s two
cset: "two" cpuset of CPUSPEC(2) with 0 tasks running</pre></div><p>
    Use of the appropriate PIDSPEC can thus be handy to move tasks and
    groups of tasks. Additionally, there is one more option that can help
    with multi-threaded processes, and that is the
    <code class="option">--threads</code> flag. If this flag is used together with the
    <code class="command">proc</code> move command with a PIDSPEC and if any of the
    task IDs in the PIDSPEC belongs to a thread in a process container, then
    <span class="emphasis"><em>all</em></span> the sibling threads in that process container
    will also get moved. This flag provides an easy mechanism to move all
    threads of a process by simply specifying one thread in that process.
    The following example moves all threads running in cpuset
    <code class="literal">three</code> to cpuset <code class="literal">two</code> by using the
    <code class="option">--threads</code> flag.
   </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set two three
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
two          2 n          0 n       0     0    /two
three        3 n          0 n       10    0    /three


<code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -l -s three
cset: "three" cpuset of CPUSPEC(3) with 10 tasks running
USER     PID   PPID  SPPr TASK NAME
-------- ----- ----- ---- ---------
tux      16165     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      16169     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      16170     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      16237     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      16491     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      16492     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      16493     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      17243     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      17244     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux      27133     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...


<code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -m -p 16165 --threads -t two
cset: moving following pidspec: 16491,16493,16492,16170,16165,16169,27133,17244,17243,16237
cset: moving 10 userspace tasks to /two
[==================================================]%
cset: done


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set two three
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
two          2 n          0 n       10    0    /two
three        3 n          0 n       0     0    /three</pre></div><section class="sect3" id="sec-shielding-cpuset-proc-move-taskset" data-id-title="Moving all tasks from one cpuset to another"><div class="titlepage"><div><div><div class="title-container"><h4 class="title"><span class="title-number-name"><span class="title-number">4.2.3.1 </span><span class="title-name">Moving all tasks from one cpuset to another</span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#sec-shielding-cpuset-proc-move-taskset">#</a></h4><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
     There is a special case for moving all tasks currently running in one
     cpuset to another. This can be a common use case, and when you need to
     do it, specifying a PIDSPEC with <code class="option">-p</code> is not necessary
     so long as you use the <code class="option">-f/--fromset</code>
     <span class="emphasis"><em>and</em></span> the <code class="option">-t/--toset</code> options.
    </p><p>
     The following example moves all 10 <code class="literal">beagled</code>
     threads back to cpuset <code class="literal">three</code> with this method.
    </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -l two three
cset: "two" cpuset of CPUSPEC(2) with 10 tasks running
USER      PID   PPID  SPPr TASK NAME
--------  ----- ----- ---- ---------
tux       16165     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -…
tux       16169     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux       16170     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux       16237     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux       16491     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux       16492     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux       16493     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux       17243     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux       17244     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
tux       27133     1 Soth beagled /usr/lib64/beagle/BeagleDaemon.exe --bg -...
cset: "three" cpuset of CPUSPEC(3) with 0 tasks running


<code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -m -f two -t three
cset: moving all tasks from two to /three
cset: moving 10 userspace tasks to /three
[==================================================]%
cset: done


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set two three
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
two          2 n          0 n       0     0    /two
three        3 n          0 n       10    0    /three</pre></div></section><section class="sect3" id="sec-shielding-cpuset-proc-move-threads" data-id-title="Kernel threads and proc"><div class="titlepage"><div><div><div class="title-container"><h4 class="title"><span class="title-number-name"><span class="title-number">4.2.3.2 </span><span class="title-name">Kernel threads and <code class="command">proc</code></span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#sec-shielding-cpuset-proc-move-threads">#</a></h4><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
     Kernel threads are special and <code class="command">cset</code> detects tasks
     that are kernel threads and will refuse to move them (since they typically
     play a vital role on particular CPU).
    </p><div id="id-1.3.6.4.6.11.3" data-id-title="Use -k or --force with care" class="admonition warning normal"><img class="symbol" alt="Warning" title="Warning" src="static/images/icon-warning.svg"/><div class="admon-title">Warning: Use <code class="option">-k</code> or <code class="option">--force</code> with care</div><p>
       Overriding a task move command with <code class="option">-k</code> or <code class="option">--force</code>
       can have dire consequences for the system. Be sure of the command before
       you force it.
     </p></div></section></section><section class="sect2" id="sec-shielding-cpuset-proc-destroy" data-id-title="Destroying tasks"><div class="titlepage"><div><div><div class="title-container"><h3 class="title"><span class="title-number-name"><span class="title-number">4.2.4 </span><span class="title-name">Destroying tasks</span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#sec-shielding-cpuset-proc-destroy">#</a></h3><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
    There actually is no <code class="command">cset</code> subcommand or option to
    destroy tasks—it is not really needed. Tasks exist and are accessible
    on the system as normal, even if they happen to be running in one cpuset
    or another. To destroy tasks, use the usual
    <span class="keycap">Ctrl</span><span class="key-connector">–</span><span class="keycap">C</span>
    method or by using the <code class="command">kill(1)</code> command.
   </p></section></section><section class="sect1" id="sec-shielding-cpuset-shielding-set-proc" data-id-title="Implementing shielding with set and proc"><div class="titlepage"><div><div><div class="title-container"><h2 class="title"><span class="title-number-name"><span class="title-number">4.3 </span><span class="title-name">Implementing shielding with <code class="command">set</code> and <code class="command">proc</code></span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#sec-shielding-cpuset-shielding-set-proc">#</a></h2><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
   With the preceding material on the <code class="command">set</code> and
   <code class="command">proc</code> subcommands, you now have the background to
   implement the basic shielding model, like the <code class="command">shield</code>
   subcommand.
  </p><p>
   While <code class="command">shield</code> provides this functionality already, doing
   this manually can still be useful. For example, to implement a shielding
   strategy that need more functionality than <code class="command">shield</code> can
   provide. In such cases, you need to first
   stop using <code class="command">shield</code> since that subcommand will interfere
   with the further application of <code class="command">set</code> and
   <code class="command">proc</code>. However, you will still need to implement the
   functionality of <code class="command">shield</code> to implement
   successful shielding.
  </p><p>
   Remember from the above sections describing <code class="command">shield</code>,
   that shielding has at minimum three cpusets: <code class="literal">root</code>,
   which is always present and contains all CPUs; <code class="literal">system</code>
   which is the <span class="emphasis"><em>non-shielded</em></span> set of CPUs and runs
   unimportant system tasks; and <code class="literal">user</code>, which is the
   <span class="emphasis"><em>shielded</em></span> set of CPUs and runs your important tasks.
   Remember also that <code class="command">shield</code> moves all movable tasks into
   <code class="literal">system</code> (except for kernel threads).
  </p><p>
   You start first by creating the <code class="literal">system</code> and
   <code class="literal">user</code> cpusets as follows. Let us assume that the machine
   is a four-CPU machine without NUMA memory features. The system cpuset
   should hold only CPU0 while the user cpuset should hold the rest of the
   CPUs.
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -c 0 -s system
cset: --&gt; created cpuset "system"


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set -c 1-3 -s user
cset: --&gt; created cpuset "user"


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set -l
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
root         0-3 y        0 y       333   2    /
user         1-3 n        0 n       0     0    /user
system       0 n          0 n       0     0    /system</pre></div><p>
   Now, move all running user processes into the
   <code class="literal">system</code> cpuset:
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -m -f root -t system
cset: moving all tasks from root to /system
cset: moving 188 userspace tasks to /system
[==================================================]%
cset: done


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set -l
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
root         0-3 y        0 y       146    2   /
user         1-3 n        0 n       0      0   /user
system       0 n          0 n       187    0   /system</pre></div><p>
   This completes the basic shielding setup. Since all user space tasks are
   running in <code class="literal">system</code>, anything that is spawned from them
   will also run in <code class="literal">system</code>. The <code class="literal">user</code>
   cpuset has nothing running in it unless you put tasks there with the
   <code class="command">proc</code> subcommand as described above. If you also want
   to eliminate kernel threads from <code class="literal">root</code> that could interfere
   with <code class="literal">user</code> workload (to achieve a form of <span class="quote">“<span class="quote">interrupt
   shielding</span>”</span> on a real time Linux kernel, for example), you should look 
   at <code class="literal">isolcpus=</code> kernel command line argument.
  </p><p>
   At this point, you have achieved the simple shielding model that the
   <code class="command">shield</code> subcommand provides. You can now add other
   cpuset definitions to expand your shielding strategy beyond that simple
   model.
  </p></section><section class="sect1" id="sec-shielding-cpuset-hierarchy-set-proc" data-id-title="Implementing hierarchy with set and proc"><div class="titlepage"><div><div><div class="title-container"><h2 class="title"><span class="title-number-name"><span class="title-number">4.4 </span><span class="title-name">Implementing hierarchy with set and proc</span></span> <a title="Permalink" class="permalink" href="cha-shielding-cpuset.html#sec-shielding-cpuset-hierarchy-set-proc">#</a></h2><div class="icons"><a target="_blank" class="icon-reportbug" title="Report an issue"> </a><a target="_blank" class="icon-editsource" href="https://github.com/SUSE/doc-slert/edit/main/xml/slert_cpuset_manipulation.xml" title="Edit source document"> </a></div></div></div></div></div><p>
   One popular extended <span class="emphasis"><em>shielding</em></span> model is based on
   hierarchical cpusets, each with diminishing numbers of CPUs. This model
   is used to create <span class="emphasis"><em>priority cpusets</em></span> that allow
   assignment of CPU resources to tasks based on some arbitrary priority
   definition. The idea is that a higher priority task will get access to
   more CPU resources than a lower priority task.
  </p><p>
   The example provided here once again assumes a machine with four CPUs and
   no NUMA memory features. This base serves to illustrate the point well;
   however, note that if your machine has (many) more CPUs, then strategies
   such as this and others get more interesting.
  </p><p>
   Define a shielding setup as in the previous section where there is a
   <code class="literal">system</code> cpuset with only CPU0 that takes care of
   <span class="quote">“<span class="quote">unimportant</span>”</span> system tasks. You will usually require this
   type of cpuset since it forms the basis of shielding. Modify the
   strategy to not use a <code class="literal">user</code> cpuset—instead create
   several new cpusets each holding one more CPU than the other. These
   cpusets will be called <code class="literal">prio_low</code> with one CPU,
   <code class="literal">prio_med</code> with two CPUs, <code class="literal">prio_high</code>
   with three CPUs, and <code class="literal">prio_all</code> with all CPUs.
  </p><div id="id-1.3.6.6.5" data-id-title="The sense behind creating a prio_all cpuset with all CPUs" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.svg"/><div class="admon-title">Note: The sense behind creating a prio_all cpuset with all CPUs</div><p>
    You may ask, why create a <code class="literal">prio_all</code> with all CPUs when
    that is substantially the definition of the <code class="literal">root</code>
    cpuset? The answer is that it is best to keep a separation between the
    <code class="literal">root</code> cpuset and everything else, even if a particular
    cpuset duplicates <code class="literal">root</code> exactly. Usually, automation
    is build on top of a cpuset strategy. In these cases, it is best to
    avoid using invariant names of cpusets, such as <code class="literal">root</code>
    for example, in this automation.
   </p></div><p>
   All of these <code class="literal">prio_*</code> cpusets can be created under root,
   in a flat way; however, it is advantageous to create them as a hierarchy.
   The reasoning for this is twofold: first, if a cpuset is destroyed, all
   its tasks are moved to its parent; second, one can use exclusive CPUs in
   a hierarchy.
  </p><p>
   If a cpuset has CPUs that are exclusive to it, then other cpusets may not
   use those CPUs unless they are children of that cpuset. This has
   more relevance to machines with many CPUs and more complex strategies.
  </p><p>
   Start with a clean slate and build the appropriate cpusets as follows:
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -r
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
root         0-3 y        0 y       344   0    /


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set -c 0-3 prio_all
cset: --&gt; created cpuset "prio_all"


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set -c 1-3 /prio_all/prio_high
cset: --&gt; created cpuset "/prio_all/prio_high"


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set -c 2-3 /prio_all/prio_high/prio_med
cset: --&gt; created cpuset "/prio_all/prio_high/prio_med"


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set -c 3 /prio_all/prio_high/prio_med/prio_low
cset: --&gt; created cpuset "/prio_all/prio_high/prio_med/prio_low"


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set -c 0 system
cset: --&gt; created cpuset "system"


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set -l -r
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
root         0-3 y        0 y       344   2    /
system       0 n          0 n       0     0    /system
prio_all     0-3 n        0 n       0     1    /prio_all
prio_high    1-3 n        0 n       0     1    /prio_all/prio_high
prio_med     2-3 n        0 n       0     1    /prio_all/prio_high/prio_med
prio_low     3 n          0 n       0     0    /prio_all/pr...rio_med/prio_low</pre></div><div id="id-1.3.6.6.10" data-id-title="Why -r/--recurse is needed in this case" class="admonition note normal"><img class="symbol" alt="Note" title="Note" src="static/images/icon-note.svg"/><div class="admon-title">Note: Why <code class="option">-r/--recurse</code> is needed in this case</div><p>
    The option <code class="option">-r</code>/<code class="option">--recurse</code> lists all the
    sets in the last command above. If you execute that command without
    <code class="option">-r/--recurse</code>, <code class="literal">prio_med</code> and
    <code class="literal">prio_low</code> cpusets would not appear.
   </p></div><p>
   The strategy is now implemented. This means that you can move all user space
   tasks into the <code class="literal">system</code> cpuset to activate the shield.
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> proc -m -f root -t system
cset: moving all tasks from root to /system
cset: moving 198 userspace tasks to /system
cset: *** not moving kernel threads, need both --force and --kthread
[==================================================]%
cset: done


<code class="prompt user">tux &gt; </code><code class="command">cset</code> set -l -r
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
root         0-3 y        0 y       146    2    /
system       0 n          0 n       198   0    /system
prio_all     0-3 n        0 n       0     1    /prio_all
prio_high    1-3 n        0 n       0     1    /prio_all/prio_high
prio_med     2-3 n        0 n       0     1    /prio_all/prio_high/prio_med
prio_low     3 n          0 n       0     0    /prio_all/pr...rio_med/prio_low</pre></div><p>
   The shield is now active. Since the <code class="literal">prio_*</code> cpuset
   names are unique, you can assign tasks to them either via their simple
   name, or their full path (as described in
   <a class="xref" href="cha-shielding-cpuset.html#sec-shielding-cpuset-proc-exec" title="4.2.2. Execing tasks with proc">Section 4.2.2, “Execing tasks with <code class="literal">proc</code>”</a>).
  </p><p>
   You may have noted that there is an ellipsis in the path of the
   <code class="literal">prio_low</code> cpuset in the listing above. This is done
   to fit the output onto an 80 character screen. To see
   the entire line, use the <code class="option">-v</code>/<code class="option">--verbose</code>
   flag as follows:
  </p><div class="verbatim-wrap"><pre class="screen"><code class="prompt user">tux &gt; </code><code class="command">cset</code> set -l -r -v
cset:
Name         CPUs-X       MEMs-X    Tasks Subs Path
------------ ---------- - ------- - ----- ---- ----------
root         0-3 y        0 y       146    2    /
system       0 n          0 n       198   0    /system
prio_all     0-3 n        0 n       0     1    /prio_all
prio_high    1-3 n        0 n       0     1    /prio_all/prio_high
prio_med     2-3 n        0 n       0     1    /prio_all/prio_high/prio_med
prio_low     3 n          0 n       0     0    /prio_all/prio_high/prio_med/prio_low</pre></div></section></section><nav class="bottom-pagination"><div><a class="pagination-link prev" href="cha-shielding-with-systemd.html"><span class="pagination-relation">Previous</span><span class="pagination-label"><span class="title-number">Chapter 3 </span>Shielding with systemd</span></a> </div><div><a class="pagination-link next" href="cha-shielding-shortcuts.html"><span class="pagination-relation">Next</span><span class="pagination-label"><span class="title-number">Chapter 5 </span>Using shortcuts</span></a> </div></nav></article><aside id="_side-toc-page" class="side-toc"><div class="side-title">On this page</div><div class="toc"><ul><li><span class="sect1"><a href="cha-shielding-cpuset.html#sec-shielding-cpuset-set"><span class="title-number">4.1 </span><span class="title-name">The set subcommand</span></a></span></li><li><span class="sect1"><a href="cha-shielding-cpuset.html#sec-shielding-cpuset-proc"><span class="title-number">4.2 </span><span class="title-name">The <code class="command">proc</code> subcommand</span></a></span></li><li><span class="sect1"><a href="cha-shielding-cpuset.html#sec-shielding-cpuset-shielding-set-proc"><span class="title-number">4.3 </span><span class="title-name">Implementing shielding with <code class="command">set</code> and <code class="command">proc</code></span></a></span></li><li><span class="sect1"><a href="cha-shielding-cpuset.html#sec-shielding-cpuset-hierarchy-set-proc"><span class="title-number">4.4 </span><span class="title-name">Implementing hierarchy with set and proc</span></a></span></li></ul></div><div class="side-title">Share this page</div><ul class="share"><li><a id="_share-fb" href="#" title="Facebook"> </a></li><li><a id="_share-in" href="#" title="LinkedIn"> </a></li><li><a id="_share-tw" href="#" title="Twitter/X"> </a></li><li><a id="_share-mail" href="#" title="E-Mail"> </a></li><li><a id="_print-button" href="#" title="Print this page"> </a></li></ul> </aside></main><footer id="_footer"><div class="growth-inhibitor"><div class="copy"><span class="copy__rights">© SUSE
                 2023</span></div></div></footer></body></html>